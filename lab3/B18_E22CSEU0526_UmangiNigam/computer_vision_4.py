# -*- coding: utf-8 -*-
"""Computer vision_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ck2mb3pCMz9GbCjHDYzfDpx7AsCviCqK
"""

#Task1
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the original image
image = cv2.imread("image.jpg")  # Replace with your image file
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # Convert to grayscale

# Function to plot histograms
def plot_histogram(image, title, color=None):
    hist = cv2.calcHist([image], [0], None, [256], [0, 256])
    plt.plot(hist, color=color)
    plt.title(title)
    plt.xlabel("Gray Levels / Intensity")
    plt.ylabel("Number of Pixels")
    plt.xlim([0, 256])

# Plot Histogram for Grayscale Image
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plot_histogram(gray, "Histogram of Grayscale Image", color="black")

# Plot Histogram for Each Channel of the Color Image
colors = ('blue', 'green', 'red')
plt.subplot(1, 2, 2)
for i, color in enumerate(colors):
    hist = cv2.calcHist([image], [i], None, [256], [0, 256])
    plt.plot(hist, color=color)
plt.title("Histogram for Color Image (RGB Channels)")
plt.xlabel("Intensity Values")
plt.ylabel("Number of Pixels")
plt.xlim([0, 256])
plt.show()

# Histogram Equalization for Contrast Enhancement
equalized_gray = cv2.equalizeHist(gray)

# Display Original and Equalized Images
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(gray, cmap="gray")
plt.title("Original Grayscale Image")
plt.axis("off")

plt.subplot(1, 2, 2)
plt.imshow(equalized_gray, cmap="gray")
plt.title("Histogram Equalized Image")
plt.axis("off")
plt.show()

# Display Histogram Before and After Equalization
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plot_histogram(gray, "Histogram Before Equalization", color="black")

plt.subplot(1, 2, 2)
plot_histogram(equalized_gray, "Histogram After Equalization", color="black")

plt.show()

#Task2
# Compute FFT of Grayscale Image
dft = np.fft.fft2(gray)
dft_shift = np.fft.fftshift(dft)  # Shift zero frequency to center
magnitude_spectrum = 20 * np.log(np.abs(dft_shift))  # Convert to log scale

# Compute Inverse FFT (IFFT)
idft_shift = np.fft.ifftshift(dft_shift)
reconstructed = np.fft.ifft2(idft_shift).real  # Convert back to real values

# Display Original, Magnitude Spectrum, and Reconstructed Image
plt.figure(figsize=(15, 5))
plt.subplot(1, 3, 1)
plt.imshow(gray, cmap="gray")
plt.title("Original Image")
plt.axis("off")

plt.subplot(1, 3, 2)
plt.imshow(magnitude_spectrum, cmap="gray")
plt.title("Magnitude Spectrum (FFT)")
plt.axis("off")

plt.subplot(1, 3, 3)
plt.imshow(reconstructed, cmap="gray")
plt.title("Reconstructed Image (IFFT)")
plt.axis("off")

plt.show()

# Verify Rotation Property of Fourier Transform
angle = 45  # Rotate by 45 degrees
(h, w) = gray.shape[:2]
center = (w // 2, h // 2)
M = cv2.getRotationMatrix2D(center, angle, 1.0)  # Create rotation matrix
rotated_image = cv2.warpAffine(gray, M, (w, h))  # Rotate image

# Compute FFT of Rotated Image
dft_rotated = np.fft.fft2(rotated_image)
dft_rotated_shift = np.fft.fftshift(dft_rotated)
magnitude_spectrum_rotated = 20 * np.log(np.abs(dft_rotated_shift))

# Display Original, Rotated Image, and FFT Spectrum
plt.figure(figsize=(15, 5))
plt.subplot(1, 3, 1)
plt.imshow(gray, cmap="gray")
plt.title("Original Image")
plt.axis("off")

plt.subplot(1, 3, 2)
plt.imshow(rotated_image, cmap="gray")
plt.title("Rotated Image (45Â°)")
plt.axis("off")

plt.subplot(1, 3, 3)
plt.imshow(magnitude_spectrum_rotated, cmap="gray")
plt.title("Magnitude Spectrum (Rotated)")
plt.axis("off")

plt.show()